# OCP Canton SDK (`@open-captable-protocol/canton`)

> High-level TypeScript SDK for Open Cap Table Protocol contracts on Canton.

## Skills

For reusable [Agent Skills](https://agentskills.io), see [github.com/HardlyDifficult/ai](https://github.com/HardlyDifficult/ai).

## Living Document

**This file is a living document.** Update it automatically when:
- A best practice or pattern is established during AI conversations
- An important architectural or coding decision is made
- The user communicates a preference that applies beyond the current task
- **Creating a PR**: Before creating a PR, review the completed task for any generalizable learnings or best practices that should be added to this file. This ensures AI improves with every task.

Keep content concise but comprehensive. Avoid verbosity—capture the essence.

## Quick Commands

```bash
npm run fix                                     # ESLint + Prettier auto-fix (REQUIRED before push)
npm run lint && npx tsc --noEmit && npm test   # Full validation
npm run test:integration                        # LocalNet integration tests
npm run docs                                    # Generate TypeDoc
```

## Pre-Push Requirements (CRITICAL)

**⚠️ ALWAYS run before committing/pushing ANY changes:**

```bash
npm run fix        # Auto-fixes ESLint and Prettier issues (MUST run before commit)
npm run typecheck  # TypeScript type checking
```

**Both commands MUST pass with zero errors and zero warnings before pushing.**

### What These Commands Do

- `npm run fix` runs:
  - ESLint with `--fix` (auto-fixes code style issues)
  - Prettier (auto-formats code)
  - **Fails if any warnings remain** (max-warnings=0)

- `npm run typecheck` runs:
  - TypeScript compiler in check mode
  - Catches type errors the IDE may miss

### If `npm run fix` Reports Warnings

Some issues can't be auto-fixed. Common manual fixes:
- **Unused imports/variables**: Remove them or prefix with `_` if intentionally unused
- **Template literal type issues**: Use `String(value)` instead of direct interpolation of `unknown` types
- **Any/unknown types**: Add proper type annotations or type guards

### CI Enforcement

- CI runs both checks on every PR
- PRs with lint errors, warnings, or type errors **will fail**
- Always verify locally before pushing to avoid CI failures

**Git workflow:** Avoid force pushing (`git push --force`). If you need to update a PR branch:
1. Merge from main: `git fetch origin main && git merge origin/main`
2. Resolve conflicts if any
3. Push normally: `git push`

This preserves commit history and makes PR review easier.

### After Creating a PR

1. **Open the PR to the files/changes page:**
   ```bash
   open <PR_URL>/files    # Review your changes
   ```

2. **Monitor CI status** and automatically investigate/fix any failures:
   ```bash
   gh pr checks <PR_NUMBER>              # Check all CI checks
   gh run view <RUN_ID> --log-failed     # View failed job logs
   gh run view --job=<JOB_ID>            # View specific job details
   ```

3. **If CI fails:** Investigate the failure, fix the issue, and push the fix. Repeat until CI passes.

## Architecture

### Layer Stack

```
ocp-canton-sdk          # This SDK - OCP operations
       │
canton-node-sdk         # Low-level Canton client
       │
Canton Network          # DAML contracts
```

### File Structure

```
src/
├── functions/              # One operation per file
│   ├── OpenCapTable/       # OCF object operations
│   │   ├── issuer/
│   │   │   ├── createIssuer.ts
│   │   │   ├── getIssuerAsOcf.ts
│   │   │   └── archiveIssuerByIssuer.ts
│   │   ├── stakeholder/
│   │   ├── stockClass/
│   │   └── ...
│   ├── CantonPayments/     # Airdrop, payment streams
│   └── OpenCapTableReports/
├── types/
│   ├── native.ts           # OCF-native input/output types
│   └── contractDetails.ts  # Disclosed contract refs
├── utils/
│   ├── typeConversions.ts  # DAML ↔ OCF conversions
│   └── TransactionBatch.ts # Multi-command helper
└── OcpClient.ts            # Facade wiring to LedgerJsonApiClient

test/
├── createOcf/              # Unit tests (mock-based)
├── fixtures/               # Test data fixtures
├── integration/            # LocalNet integration tests
│   ├── setup/              # Test harness and factories
│   │   ├── integrationTestHarness.ts  # Shared context, client init
│   │   ├── entityTestFactory.ts       # Generic test patterns
│   │   └── index.ts
│   ├── entities/           # Per-entity test files
│   │   ├── issuer.integration.test.ts
│   │   ├── stakeholder.integration.test.ts
│   │   ├── stockClass.integration.test.ts        # Complete example
│   │   ├── stockClassAuthorizedSharesAdjustment.integration.test.ts
│   │   └── ...
│   ├── workflows/          # Multi-entity workflow tests
│   │   └── capTableWorkflow.integration.test.ts
│   ├── utils/              # Test data factories
│   │   └── setupTestData.ts
│   └── quickstart.smoke.test.ts
├── mocks/                  # Mock implementations
└── utils/                  # Shared test utilities
    ├── testConfig.ts       # Environment config
    ├── fixtureHelpers.ts   # Fixture management
    └── ocfSchemaValidator.ts
```

## Function Pattern

Each operation exports: `Params`, `Result`, function, and optionally `buildXCommand`.

```typescript
// src/functions/OpenCapTable/stakeholder/createStakeholder.ts
export interface CreateStakeholderParams {
  issuerContractId: ContractId;
  stakeholderData: OcfStakeholder;
  featuredAppRightContractDetails: ContractDetails;
}

export interface CreateStakeholderResult {
  stakeholderContractId: ContractId;
}

export function buildCreateStakeholderCommand(
  params: CreateStakeholderParams
): CommandWithDisclosedContracts {
  const { stakeholderData: d } = params;

  // Validate (fail fast)
  if (!d.id) throw new Error('stakeholder.id is required');

  // Build command with explicit field mapping (NO spread)
  const choiceArguments = {
    stakeholder_data: {
      id: d.id,
      name: d.name,
      stakeholder_type: d.stakeholder_type,
      // ... all fields explicit
    },
  };

  return { command, disclosedContracts };
}
```

## Type Conversions

Use utilities from `src/utils/typeConversions.ts`:

```typescript
import {
  numberToString,         // number|string → string (for DAML numerics)
  normalizeNumericString, // Normalize and validate numeric strings (throws on invalid input)
  optionalString,         // empty/undefined → null
  cleanComments,          // filter comments array
  dateStringToDAMLTime,   // ISO date → DAML time
  monetaryToDaml,         // monetary object → DAML format
  damlMonetaryToNative,   // DAML monetary → native (with validation)
} from '../../utils/typeConversions';
```

**Type conversion best practices:**

1. **Validate before converting** - Check for null/undefined before calling conversion functions
2. **Use `.toString()` not `String()`** - When you've validated a value is not null/undefined, use `.toString()`
3. **Let validation functions throw** - Functions like `normalizeNumericString()` throw on invalid input
4. **Example pattern:**
   ```typescript
   // ❌ Bad - creates "undefined" if amount is undefined
   const amount = String(data.amount);

   // ✅ Good - validates then converts
   if (data.amount === undefined || data.amount === null) {
     throw new Error('amount is required');
   }
   const amount = typeof data.amount === 'number'
     ? data.amount.toString()
     : data.amount;
   ```

## Non-Negotiables

1. **Strict TypeScript** - No `any`/`unknown`, no broad assertions
   - Use type guards instead of `as any` casts
   - Prefer `unknown` + type narrowing over `any` when type is truly unknown
   - Extract proper types from external libraries when possible
2. **Fail fast** - Validate early, throw with actionable messages
3. **Never silently ignore errors** - Prefer failing over hiding problems
   - No empty catch blocks that swallow errors
   - No early returns that make tests "pass" when they didn't run
   - If something fails, it should fail visibly with a clear error message
   - Tests must actually test - if infrastructure is missing, tests should fail, not skip
4. **No unsafe type coercion** - ALWAYS validate before converting types
   - **NEVER** use `String(value)` on potentially undefined/null values (creates `"undefined"` or `"null"` strings)
   - **NEVER** use `Number(value)` on potentially invalid strings (creates `NaN`)
   - **ALWAYS** validate the type first, then convert with explicit error handling
   - Example: ❌ `String(amount)` → ✅ `if (!amount) throw new Error('...'); amount.toString()`
   - Use `.toString()` instead of `String()` when you've validated the value is not null/undefined
5. **Explicit fields** - List all fields, never use spread (`...d`)
6. **No defensive checks** - Trust DAML types, don't check `Array.isArray()`
7. **Use `null`** for DAML optional fields (not `undefined`)
8. **Use `??`** instead of `||` for nullish coalescing
9. **Pinned dependencies** - ALWAYS use exact versions without `^` or `~`
   - ✅ Correct: `"jsonwebtoken": "9.0.3"`
   - ❌ Wrong: `"jsonwebtoken": "^9.0.3"` or `"~9.0.3"`
   - This applies to ALL dependencies (dependencies, devDependencies, peerDependencies)
   - When adding packages: `npm install --save-exact <package>` or manually remove `^`/`~` after install
10. **DRY code** - Extract duplicated logic into reusable helpers (especially in tests)

## Improvement Backlog Pattern

When you discover areas for improvement that are **unrelated to the current task**:

1. **Don't fix inline** - Keep PRs focused on the task at hand
2. **Document as backlog** - Create or update an improvement ideas file in the task directory
3. **Reference from main task** - Ensure the parent task links to improvement subtasks
4. **Address before marking complete** - Main tasks should not be closed until improvement items are resolved

**Location:** `canton/tasks/YYYY/MM/{task-name}/sdk-improvement-ideas.md`

**Example items:**
- Dead code (functions referencing non-existent DAML choices)
- Type inconsistencies across similar functions
- Missing test coverage
- Configuration issues (ESLint, tsconfig)
- Duplicated utility functions

This ensures improvements aren't lost while keeping PRs focused and reviewable.

## Testing Strategy

### Test Types

| Test Type | Command | Purpose |
|-----------|---------|---------|
| Unit tests | `npm test` | Mock-based tests for conversions, validation |
| Integration tests | `npm run test:integration` | LocalNet tests validating DAML contracts |
| Type checking | `npm run typecheck` | TypeScript compilation checks |

### Unit Tests (Mock-based)

Unit tests use mocked Canton responses for fast, deterministic testing:

```typescript
// test/createOcf/dynamic.test.ts
import { setTransactionTreeFixtureData } from '../utils/fixtureHelpers';
import { validateOcfObject } from '../utils/ocfSchemaValidator';

test('creates issuer with valid OCF output', async () => {
  setTransactionTreeFixtureData(fixture);
  const result = await createIssuer(client, params);
  await validateOcfObject(result.issuer);
});
```

### Integration Tests (LocalNet)

Integration tests run against a real Canton LocalNet environment. They catch issues that mocks miss:
- Invalid DAML command structure
- Type conversion errors that only surface at runtime
- Incorrect template IDs or choice names
- Contract workflow validation

**Running integration tests:**

```bash
# Start LocalNet (cn-quickstart) first
npm run test:integration
```

**Integration test structure:**

Tests are organized by entity type with shared infrastructure:
- `setup/` - Harness for client init, party discovery, validator API detection
- `entities/` - One test file per OCF entity type
- `workflows/` - Multi-entity workflow tests
- `utils/` - Data factories and helpers:
  - `setupTestData.ts` - Entity setup functions (`setupTestIssuer`, `createTestStockClassData`)
  - `transactionHelpers.ts` - Type-safe transaction tree utilities (`extractContractIdOrThrow`)

**Integration test pattern (using harness):**

```typescript
// test/integration/entities/issuer.integration.test.ts
import { createIntegrationTestSuite } from '../setup';
import { generateTestId, setupTestIssuer } from '../utils';

createIntegrationTestSuite('Issuer operations', (getContext) => {
  test('creates issuer and reads it back as valid OCF', async () => {
    const ctx = getContext();  // Throws if LocalNet not available

    const issuerSetup = await setupTestIssuer(ctx.ocp, {
      issuerParty: ctx.issuerParty,
      featuredAppRightContractDetails: ctx.featuredAppRight,
      issuerData: { id: generateTestId('issuer'), legal_name: 'Test Corp' },
    });

    const ocfResult = await ctx.ocp.OpenCapTable.issuer.getIssuerAsOcf({
      contractId: issuerSetup.issuerContractId,
    });

    expect(ocfResult.issuer.object_type).toBe('ISSUER');
    await validateOcfObject(ocfResult.issuer);
  });
});
```

**Note:** Tests fail fast if LocalNet is not running. There is no silent skipping - if infrastructure is missing, tests fail with a clear error message. This ensures CI catches missing infrastructure rather than falsely reporting success.

**Adding tests for a new entity type:**

1. Create `test/integration/entities/{entity}.integration.test.ts`
2. Use `createIntegrationTestSuite()` for automatic harness setup
3. Add data factory in `test/integration/utils/setupTestData.ts` if needed
4. Reference `stockClass.integration.test.ts` as the complete example

**Benefits of integration tests:**
- Validates end-to-end OCF compliance
- Tests actual DAML contract behavior
- Catches runtime issues before merge
- Builds confidence in contract implementations

### OCF Schema Validation

Tests validate against official OCF JSON schemas:

```bash
git submodule update --init --recursive  # Get schemas
npm test                                  # Validates fixtures
```

```typescript
import { validateOcfObject } from './test/utils/ocfSchemaValidator';
await validateOcfObject({ object_type: 'ISSUER', ... });
```

## Adding a New OCF Operation

1. Create file: `src/functions/OpenCapTable/{entity}/{operation}.ts`
2. Define `Params`, `Result` interfaces
3. Implement operation function
4. Add `buildXCommand` for batch support
5. Export from `src/functions/OpenCapTable/{entity}/index.ts`
6. Add to `OcpClient.ts`
7. Add test fixture in `test/fixtures/`

## LocalNet (cn-quickstart)

The SDK includes cn-quickstart as a git submodule for local development and testing.

### Location

```
libs/cn-quickstart/quickstart/   # cn-quickstart directory
```

### First-Time Setup

```bash
# Navigate to cn-quickstart
cd libs/cn-quickstart/quickstart

# Run interactive setup (creates .env.local)
make setup
# Choose: OAuth2 mode, set party hint (e.g., "quickstart-dev-1")

# Install DAML SDK (if not already installed)
make install-daml-sdk
```

### Starting LocalNet

```bash
cd libs/cn-quickstart/quickstart
make start   # Builds and starts all containers
```

Wait ~4-5 minutes for all services to become healthy. Check status:

```bash
docker ps --format "table {{.Names}}\t{{.Status}}"
```

All services should show "healthy" before running tests.

### Stopping LocalNet

```bash
cd libs/cn-quickstart/quickstart
make stop              # Stop all containers
make clean-all-docker  # Stop and remove all containers/volumes (full reset)
```

### Running Integration Tests Against LocalNet

**IMPORTANT: Always run integration tests locally before pushing to verify DAML contract compatibility.**

Unit tests (`npm run test:ci`) only verify TypeScript logic with mocked clients. Integration tests (`npm run test:integration`) verify actual DAML contract interactions and can fail due to:
- Invalid data that DAML contracts reject (e.g., empty required arrays)
- Type mismatches between SDK and DAML schemas
- Missing required fields that TypeScript doesn't enforce

```bash
# 1. Start LocalNet with shared-secret mode
cd libs/cn-quickstart/quickstart
echo 'AUTH_MODE=shared-secret' >> .env.local
make clean-all-docker  # Reset to apply new config
make start

# 2. Wait for services (check all show "healthy")
docker ps --format "table {{.Names}}\t{{.Status}}"

# 3. Run integration tests
npm run test:integration

# 4. Fix any failures before pushing
```

**Pre-push checklist:**
1. `npm run fix` - Format and lint
2. `npm run test:ci` - Unit tests
3. `npm run test:integration` - Integration tests (requires LocalNet)

Note: Integration tests use shared-secret authentication by default. DAR files are auto-discovered from the `@fairmint/open-captable-protocol-daml-js` npm package.

### LocalNet Services and Ports

| Service | Port | Description |
|---------|------|-------------|
| App-Provider JSON API | 3975 | Ledger API for app_provider participant |
| App-Provider Validator | 3903 | Validator API for app_provider |
| App-User JSON API | 2975 | Ledger API for app_user participant |
| SV JSON API | 4975 | Ledger API for super validator |
| Keycloak | 8082 | OAuth2 authentication |
| Scan API | scan.localhost:4000 | Network-wide contract queries |
| Swagger UI | 9090 | API documentation |
| Grafana | 3030 | Observability dashboard |

### OAuth2 Credentials (app-provider)

Default LocalNet OAuth2 credentials (used when OAuth2 mode is configured):

```
Auth URL: http://localhost:8082/realms/AppProvider/protocol/openid-connect/token
Client ID: app-provider-validator
Client Secret: AL8648b9SfdTFImq7FV56Vd0KHifHBuC
```

### Troubleshooting LocalNet

#### "Cannot connect to Docker daemon"
```bash
# Start Docker Desktop, then verify
docker ps
```

#### "HTTP 503" or "Connection refused" during tests
Services aren't ready yet. Wait for all containers to show "healthy":
```bash
docker ps --format "table {{.Names}}\t{{.Status}}" | grep -v healthy
# Should return nothing when ready (all healthy)
```

#### "Container keeps restarting"
Reset everything and start fresh:
```bash
cd libs/cn-quickstart/quickstart
make clean-all-docker  # Removes all containers and volumes
make start
```

#### "Port already in use"
Stop existing containers or find conflicting process:
```bash
make stop              # Stop LocalNet containers
lsof -i :3975          # Find what's using JSON API port
```

#### "DAR upload failed" or "Package not found"
Canton may have restarted, clearing deployed packages. Tests auto-deploy DARs on startup.

#### Integration tests timeout
LocalNet startup can take 4-5 minutes. Ensure all services are healthy before running tests.

### Known Limitations

1. **OAuth2 Disclosed Contracts**: In OAuth2 mode, the app_provider can't fetch `createdEventBlob` for contracts it doesn't own (returns 403). This breaks the disclosed contracts mechanism needed for cross-party visibility. **Solution:** Use shared-secret auth mode for full integration test coverage (`make setup` and select shared-secret).

2. **First-time startup**: The first `make start` takes longer as it builds images and compiles DAML code.

3. **Resource usage**: LocalNet runs ~20+ containers and requires significant RAM (recommend 8GB+ available for Docker).

4. **State persistence**: Canton restarts (via Docker or health checks) clear all ledger state including deployed DARs, created factories, and contracts. Tests must handle re-deployment.

### Useful Make Targets

```bash
make status            # Show container status
make logs              # View all logs
make tail              # Tail logs in real-time
make restart           # Stop and start
make canton-console    # Interactive Canton console
```

## NPM Publishing

The package `@open-captable-protocol/canton` is automatically published to NPM when changes are merged to `main`.

### How It Works

1. **Create a PR** with your changes
2. **Get it reviewed** and approved
3. **Merge to main** - CI automatically:
   - Builds the package and runs tests
   - Runs integration smoke tests
   - Increments the patch version in `package.json`
   - Generates a changelog from commits since last release
   - Publishes to NPM
   - Creates and pushes a git tag (e.g., `v0.2.79`)
   - Deploys documentation to GitHub Pages

### Version Bumping

- **Patch bumps** (0.2.78 → 0.2.79): Automatic on every merge to main
- **Minor/Major bumps**: Manually update `package.json` version before merging

### Manual Release (Local)

```bash
npm run prepare-release   # Bumps version, generates changelog
npm publish               # Publishes to NPM (requires NPM_TOKEN)
```

### CI Requirements

The publish workflow requires:
- `NPM_TOKEN` secret configured in GitHub repository settings

## Related Repos

| Repo | Purpose | Docs |
|------|---------|------|
| `canton` | Trading infrastructure, ADRs | `llms.txt` |
| `canton-explorer` | Next.js explorer UI | `llms.txt`, [cantonops.fairmint.com](https://cantonops.fairmint.com/) |
| `canton-fairmint-sdk` | Shared TypeScript utilities | `llms.txt` |
| `canton-node-sdk` | Low-level Canton client | `llms.txt`, [sdk.canton.fairmint.com](https://sdk.canton.fairmint.com/) |
| `ocp-position-nft` | Soulbound NFT smart contracts | `llms.txt` |
| `open-captable-protocol-daml` | DAML contracts (OCF impl) | `llms.txt` |
| `open-cap-format-ocf` | OCF JSON schemas (submodule) | [GitHub](https://github.com/Open-Cap-Table-Coalition/Open-Cap-Format-OCF) |

## Architecture Decision Records (ADRs)

ADRs document significant architectural decisions. They live in the `adr/` directory.

**ADR Index:** See [adr/README.md](adr/README.md) for the current ADR index.

**When creating a new ADR:**

1. Create the ADR file: `adr/NNN-short-title.md` (NNN = next sequential number)
2. **ALWAYS update `adr/README.md`** to add the new ADR to the index table
3. Link the ADR from any related task files

**ADR Status Values:** Proposed → Accepted → (Superseded/Rejected)

## Tasks

Task tracking lives in the `tasks/` directory. See [tasks/README.md](tasks/README.md) for the current task index.

**⚠️ CRITICAL: Always update `tasks/README.md` when changing task status!**

**Format note:** The task index uses Markdown lists (not tables) to reduce merge conflicts. Each task is on its own lines, so changes to different tasks are less likely to conflict.

**Task Index Maintenance:** When adding or completing tasks:

1. **Adding a new task:** Create the task file in `tasks/YYYY/MM/` and add an entry to the appropriate priority section in `tasks/README.md`
2. **Completing a task:** Update the task's status to "Complete" in the task file **AND** move it to the "Completed Tasks" section in `tasks/README.md`
3. **Keep the index current:** The `tasks/README.md` should always reflect the actual state of tasks

**Changelog Requirement:** When creating PRs for this repo, update the parent task's changelog. Every PR must be logged with date, description, and PR links.

## Docs

- End-user docs: [ocp.canton.fairmint.com](https://ocp.canton.fairmint.com/)
- TypeDoc: `npm run docs` → `docs/`
- Implementation guide: `README.md`
- Code style: `CONTRIBUTING.md`
- Lint config: `LINTING.md`
