# OCP Canton SDK (`@open-captable-protocol/canton`)

> High-level TypeScript SDK for Open Cap Table Protocol contracts on Canton.

## Living Document

**This file is a living document.** Update it automatically when:
- A best practice or pattern is established during AI conversations
- An important architectural or coding decision is made
- The user communicates a preference that applies beyond the current task

Keep content concise but comprehensive. Avoid verbosity—capture the essence.

## Quick Commands

```bash
npm run fix                                     # ESLint + Prettier auto-fix (REQUIRED before push)
npm run lint && npx tsc --noEmit && npm test   # Full validation
npm run test:integration                        # LocalNet integration tests
npm run docs                                    # Generate TypeDoc
```

## Pre-Push Requirements (CRITICAL)

**⚠️ ALWAYS run before pushing ANY changes or opening PRs:**

```bash
npm run fix        # Auto-fixes ESLint and Prettier issues
npm run typecheck  # TypeScript type checking
```

**Both commands MUST pass with zero errors and zero warnings before pushing.**

### What These Commands Do

- `npm run fix` runs:
  - ESLint with `--fix` (auto-fixes code style issues)
  - Prettier (auto-formats code)
  - **Fails if any warnings remain** (max-warnings=0)

- `npm run typecheck` runs:
  - TypeScript compiler in check mode
  - Catches type errors the IDE may miss

### If `npm run fix` Reports Warnings

Some issues can't be auto-fixed. Common manual fixes:
- **Unused imports/variables**: Remove them or prefix with `_` if intentionally unused
- **Template literal type issues**: Use `String(value)` instead of direct interpolation of `unknown` types
- **Any/unknown types**: Add proper type annotations or type guards

### CI Enforcement

- CI runs both checks on every PR
- PRs with lint errors, warnings, or type errors **will fail**
- Always verify locally before pushing to avoid CI failures

**Git workflow:** Avoid force pushing (`git push --force`). If you need to update a PR branch:
1. Merge from main: `git fetch origin main && git merge origin/main`
2. Resolve conflicts if any
3. Push normally: `git push`

This preserves commit history and makes PR review easier.

## Architecture

### Layer Stack

```
ocp-canton-sdk          # This SDK - OCP operations
       │
canton-node-sdk         # Low-level Canton client
       │
Canton Network          # DAML contracts
```

### File Structure

```
src/
├── functions/              # One operation per file
│   ├── OpenCapTable/       # OCF object operations
│   │   ├── issuer/
│   │   │   ├── createIssuer.ts
│   │   │   ├── getIssuerAsOcf.ts
│   │   │   └── archiveIssuerByIssuer.ts
│   │   ├── stakeholder/
│   │   ├── stockClass/
│   │   └── ...
│   ├── CantonPayments/     # Airdrop, payment streams
│   └── OpenCapTableReports/
├── types/
│   ├── native.ts           # OCF-native input/output types
│   └── contractDetails.ts  # Disclosed contract refs
├── utils/
│   ├── typeConversions.ts  # DAML ↔ OCF conversions
│   └── TransactionBatch.ts # Multi-command helper
└── OcpClient.ts            # Facade wiring to LedgerJsonApiClient

test/
├── createOcf/              # Unit tests (mock-based)
├── fixtures/               # Test data fixtures
├── integration/            # LocalNet integration tests
│   ├── setup/              # Test harness and factories
│   │   ├── integrationTestHarness.ts  # Shared context, client init
│   │   ├── entityTestFactory.ts       # Generic test patterns
│   │   └── index.ts
│   ├── entities/           # Per-entity test files
│   │   ├── issuer.integration.test.ts
│   │   ├── stakeholder.integration.test.ts
│   │   ├── stockClass.integration.test.ts        # Complete example
│   │   ├── stockClassAuthorizedSharesAdjustment.integration.test.ts
│   │   └── ...
│   ├── workflows/          # Multi-entity workflow tests
│   │   └── capTableWorkflow.integration.test.ts
│   ├── utils/              # Test data factories
│   │   └── setupTestData.ts
│   └── quickstart.smoke.test.ts
├── mocks/                  # Mock implementations
└── utils/                  # Shared test utilities
    ├── testConfig.ts       # Environment config
    ├── fixtureHelpers.ts   # Fixture management
    └── ocfSchemaValidator.ts
```

## Function Pattern

Each operation exports: `Params`, `Result`, function, and optionally `buildXCommand`.

```typescript
// src/functions/OpenCapTable/stakeholder/createStakeholder.ts
export interface CreateStakeholderParams {
  issuerContractId: ContractId;
  stakeholderData: OcfStakeholderData;
  featuredAppRightContractDetails: ContractDetails;
}

export interface CreateStakeholderResult {
  stakeholderContractId: ContractId;
}

export function buildCreateStakeholderCommand(
  params: CreateStakeholderParams
): CommandWithDisclosedContracts {
  const { stakeholderData: d } = params;

  // Validate (fail fast)
  if (!d.id) throw new Error('stakeholder.id is required');

  // Build command with explicit field mapping (NO spread)
  const choiceArguments = {
    stakeholder_data: {
      id: d.id,
      name: d.name,
      stakeholder_type: d.stakeholder_type,
      // ... all fields explicit
    },
  };

  return { command, disclosedContracts };
}
```

## Type Conversions

Use utilities from `src/utils/typeConversions.ts`:

```typescript
import {
  numberToString,        // number|string → string (for DAML numerics)
  optionalString,        // empty/undefined → null
  cleanComments,         // filter comments array
  dateStringToDAMLTime,  // ISO date → DAML time
  monetaryToDaml,        // monetary object → DAML format
} from '../../utils/typeConversions';
```

## Non-Negotiables

1. **Strict TypeScript** - No `any`/`unknown`, no broad assertions
   - Use type guards instead of `as any` casts
   - Prefer `unknown` + type narrowing over `any` when type is truly unknown
   - Extract proper types from external libraries when possible
2. **Fail fast** - Validate early, throw with actionable messages
3. **Never silently ignore errors** - Prefer failing over hiding problems
   - No empty catch blocks that swallow errors
   - No early returns that make tests "pass" when they didn't run
   - If something fails, it should fail visibly with a clear error message
   - Tests must actually test - if infrastructure is missing, tests should fail, not skip
4. **Explicit fields** - List all fields, never use spread (`...d`)
5. **No defensive checks** - Trust DAML types, don't check `Array.isArray()`
6. **Use `null`** for DAML optional fields (not `undefined`)
7. **Use `??`** instead of `||` for nullish coalescing
8. **Pinned dependencies** - Use exact versions without `^` or `~` (e.g., `"1.2.3"` not `"^1.2.3"`)
9. **DRY code** - Extract duplicated logic into reusable helpers (especially in tests)

## Improvement Backlog Pattern

When you discover areas for improvement that are **unrelated to the current task**:

1. **Don't fix inline** - Keep PRs focused on the task at hand
2. **Document as backlog** - Create or update an improvement ideas file in the task directory
3. **Reference from main task** - Ensure the parent task links to improvement subtasks
4. **Address before marking complete** - Main tasks should not be closed until improvement items are resolved

**Location:** `canton/tasks/YYYY/MM/{task-name}/sdk-improvement-ideas.md`

**Example items:**
- Dead code (functions referencing non-existent DAML choices)
- Type inconsistencies across similar functions
- Missing test coverage
- Configuration issues (ESLint, tsconfig)
- Duplicated utility functions

This ensures improvements aren't lost while keeping PRs focused and reviewable.

## Testing Strategy

### Test Types

| Test Type | Command | Purpose |
|-----------|---------|---------|
| Unit tests | `npm test` | Mock-based tests for conversions, validation |
| Integration tests | `npm run test:integration` | LocalNet tests validating DAML contracts |
| Type checking | `npm run typecheck` | TypeScript compilation checks |

### Unit Tests (Mock-based)

Unit tests use mocked Canton responses for fast, deterministic testing:

```typescript
// test/createOcf/dynamic.test.ts
import { setTransactionTreeFixtureData } from '../utils/fixtureHelpers';
import { validateOcfObject } from '../utils/ocfSchemaValidator';

test('creates issuer with valid OCF output', async () => {
  setTransactionTreeFixtureData(fixture);
  const result = await createIssuer(client, params);
  await validateOcfObject(result.issuer);
});
```

### Integration Tests (LocalNet)

Integration tests run against a real Canton LocalNet environment. They catch issues that mocks miss:
- Invalid DAML command structure
- Type conversion errors that only surface at runtime
- Incorrect template IDs or choice names
- Contract workflow validation

**Running integration tests:**

```bash
# Start LocalNet (cn-quickstart) first
OCP_TEST_USE_CN_QUICKSTART_DEFAULTS=true npm run test:integration
```

**Integration test structure:**

Tests are organized by entity type with shared infrastructure:
- `setup/` - Harness for client init, party discovery, validator API detection
- `entities/` - One test file per OCF entity type
- `workflows/` - Multi-entity workflow tests
- `utils/` - Data factories and helpers:
  - `setupTestData.ts` - Entity setup functions (`setupTestIssuer`, `createTestStockClassData`)
  - `transactionHelpers.ts` - Type-safe transaction tree utilities (`extractContractIdOrThrow`)

**Integration test pattern (using harness):**

```typescript
// test/integration/entities/issuer.integration.test.ts
import { createIntegrationTestSuite } from '../setup';
import { generateTestId, setupTestIssuer } from '../utils';

createIntegrationTestSuite('Issuer operations', (getContext) => {
  test('creates issuer and reads it back as valid OCF', async () => {
    const ctx = getContext();  // Throws if LocalNet not available

    const issuerSetup = await setupTestIssuer(ctx.ocp, {
      issuerParty: ctx.issuerParty,
      featuredAppRightContractDetails: ctx.featuredAppRight,
      issuerData: { id: generateTestId('issuer'), legal_name: 'Test Corp' },
    });

    const ocfResult = await ctx.ocp.OpenCapTable.issuer.getIssuerAsOcf({
      contractId: issuerSetup.issuerContractId,
    });

    expect(ocfResult.issuer.object_type).toBe('ISSUER');
    await validateOcfObject(ocfResult.issuer);
  });
});
```

**Note:** Tests fail fast if LocalNet is not running. There is no silent skipping - if infrastructure is missing, tests fail with a clear error message. This ensures CI catches missing infrastructure rather than falsely reporting success.

**Adding tests for a new entity type:**

1. Create `test/integration/entities/{entity}.integration.test.ts`
2. Use `createIntegrationTestSuite()` for automatic harness setup
3. Add data factory in `test/integration/utils/setupTestData.ts` if needed
4. Reference `stockClass.integration.test.ts` as the complete example

**Benefits of integration tests:**
- Validates end-to-end OCF compliance
- Tests actual DAML contract behavior
- Catches runtime issues before merge
- Builds confidence in contract implementations

### OCF Schema Validation

Tests validate against official OCF JSON schemas:

```bash
git submodule update --init --recursive  # Get schemas
npm test                                  # Validates fixtures
```

```typescript
import { validateOcfObject } from './test/utils/ocfSchemaValidator';
await validateOcfObject({ object_type: 'ISSUER', ... });
```

## Adding a New OCF Operation

1. Create file: `src/functions/OpenCapTable/{entity}/{operation}.ts`
2. Define `Params`, `Result` interfaces
3. Implement operation function
4. Add `buildXCommand` for batch support
5. Export from `src/functions/OpenCapTable/{entity}/index.ts`
6. Add to `OcpClient.ts`
7. Add test fixture in `test/fixtures/`

## LocalNet (cn-quickstart)

The SDK includes cn-quickstart as a git submodule for local development and testing.

### Location

```
libs/cn-quickstart/quickstart/   # cn-quickstart directory
```

### First-Time Setup

```bash
# Navigate to cn-quickstart
cd libs/cn-quickstart/quickstart

# Run interactive setup (creates .env.local)
make setup
# Choose: OAuth2 mode, set party hint (e.g., "quickstart-dev-1")

# Install DAML SDK (if not already installed)
make install-daml-sdk
```

### Starting LocalNet

```bash
cd libs/cn-quickstart/quickstart
make start   # Builds and starts all containers
```

Wait ~4-5 minutes for all services to become healthy. Check status:

```bash
docker ps --format "table {{.Names}}\t{{.Status}}"
```

All services should show "healthy" before running tests.

### Stopping LocalNet

```bash
cd libs/cn-quickstart/quickstart
make stop              # Stop all containers
make clean-all-docker  # Stop and remove all containers/volumes (full reset)
```

### Running Integration Tests Against LocalNet

**Shared-Secret Mode (Recommended for Local Development):**

```bash
# Configure LocalNet for shared-secret mode
cd libs/cn-quickstart/quickstart
echo 'AUTH_MODE=shared-secret' >> .env.local
make clean-all-docker  # Reset to apply new config
make start

# Run integration tests with shared-secret auth
OCP_TEST_USE_CN_QUICKSTART_DEFAULTS=1 \
OCP_TEST_AUTH_MODE=shared-secret \
OCP_TEST_DAR_FILE_PATH=/path/to/OpenCapTable-v25-0.0.1.dar \
npm run test:integration
```

**OAuth2 Mode:**

```bash
# Configure LocalNet for OAuth2 (default)
cd libs/cn-quickstart/quickstart
echo 'AUTH_MODE=oauth2' >> .env.local
make start

# Run integration tests with OAuth2 auth
OCP_TEST_USE_CN_QUICKSTART_DEFAULTS=1 npm run test:integration
```

Note: OAuth2 mode requires the DAR to be pre-deployed to LocalNet.

### LocalNet Services and Ports

| Service | Port | Description |
|---------|------|-------------|
| App-Provider JSON API | 3975 | Ledger API for app_provider participant |
| App-Provider Validator | 3903 | Validator API for app_provider |
| App-User JSON API | 2975 | Ledger API for app_user participant |
| SV JSON API | 4975 | Ledger API for super validator |
| Keycloak | 8082 | OAuth2 authentication |
| Scan API | scan.localhost:4000 | Network-wide contract queries |
| Swagger UI | 9090 | API documentation |
| Grafana | 3030 | Observability dashboard |

### OAuth2 Credentials (app-provider)

Used by SDK when `OCP_TEST_USE_CN_QUICKSTART_DEFAULTS=1`:

```
Auth URL: http://localhost:8082/realms/AppProvider/protocol/openid-connect/token
Client ID: app-provider-validator
Client Secret: AL8648b9SfdTFImq7FV56Vd0KHifHBuC
```

### Known Limitations

1. **OAuth2 Disclosed Contracts**: In OAuth2 mode, the app_provider can't fetch `createdEventBlob` for contracts it doesn't own (returns 403). This breaks the disclosed contracts mechanism needed for cross-party visibility. **Solution:** Use shared-secret auth mode for full integration test coverage (`make setup` and select shared-secret).

2. **First-time startup**: The first `make start` takes longer as it builds images and compiles DAML code.

3. **Resource usage**: LocalNet runs ~20+ containers and requires significant RAM (recommend 8GB+ available for Docker).

4. **State persistence**: Canton restarts (via Docker or health checks) clear all ledger state including deployed DARs, created factories, and contracts. Tests must handle re-deployment.

### Useful Make Targets

```bash
make status            # Show container status
make logs              # View all logs
make tail              # Tail logs in real-time
make restart           # Stop and start
make canton-console    # Interactive Canton console
```

## Related Repos

| Repo | Purpose |
|------|---------|
| `canton-node-sdk` | Low-level Canton client |
| `canton` | Trading infrastructure, ADRs |
| `open-captable-protocol-daml` | DAML contracts (OCF implementation) |
| `Open-Cap-Format-OCF` | OCF JSON schemas (submodule) |

## Tasks

All tasks tracked in [canton/tasks](https://github.com/fairmint/canton/tree/main/tasks).

**Changelog Requirement:** When creating PRs for this repo, update the parent task's changelog in `canton/tasks`. Every PR must be logged with date, description, and PR links. See `canton/llms.txt` for the full changelog format.

## Docs

- End-user docs: [ocp.canton.fairmint.com](https://ocp.canton.fairmint.com/)
- TypeDoc: `npm run docs` → `docs/`
- Implementation guide: `README.md`
- Code style: `CONTRIBUTING.md`
- Lint config: `LINTING.md`
