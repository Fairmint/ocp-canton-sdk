# Task: Add CouponMinter TPS Rate Limit Helper Functions

## Repo

`ocp-canton-sdk`

## Feature Summary

Add utility functions to help JavaScript/TypeScript clients determine if they can call `MintCoupons`
on a `CouponMinter` contract without hitting the TPS rate limit. The CouponMinter contract enforces
a TPS limit based on the previous mint count and elapsed time since the last mint. Clients need a
way to check this locally before attempting a transaction.

## Trigger

When a client wants to mint coupons and needs to know:

1. Whether they can mint now without the transaction failing due to TPS limits
2. How long they need to wait before minting is allowed

## Affected Areas

- Add: `src/functions/CouponMinter/index.ts` - New module for CouponMinter utilities
- Add: `src/functions/CouponMinter/canMintCouponsNow.ts` - Core helper function
- `src/functions/index.ts` - Export new functions
- `src/OcpClient.ts` - Add CouponMinter namespace to client (optional)

## Implementation Approach

The `CouponMinter` contract (from `open-captable-protocol-daml`) has the following rate limiting
logic:

```daml
-- From CouponMinter.daml lines 56-64
case (maxTps, lastMint) of
  (Some tps, Some lm) -> do
    let minIntervalMicros = intToDecimal lm.count * 1000000.0 / tps
    let elapsed : RelTime = subTime now lm.time
    let elapsedMicros = intToDecimal (convertRelTimeToMicroseconds elapsed)
    assertMsg
      ("TPS limit exceeded...")
      (elapsedMicros >= minIntervalMicros)
  _ -> pure ()
```

Key insight: The required wait interval depends on `lastMint.count` (how many coupons were minted
last time), NOT the count you want to mint now.

## Implementation Steps

1. [ ] Create types for CouponMinter contract payload - low
   - [ ] Define `LastMint` interface with `time: string` and `count: number`
   - [ ] Define `CouponMinterPayload` interface with `operator: string`, `maxTps: string | null`,
         `lastMint: LastMint | null`
   - [ ] Define `CanMintResult` type for return value

2. [ ] Implement `canMintCouponsNow` function - low
   - [ ] Accept `CouponMinterPayload` and optional `now?: Date` parameter
   - [ ] Return `{ canMint: true }` if `maxTps` is null/undefined
   - [ ] Return `{ canMint: true }` if `lastMint` is null/undefined
   - [ ] Parse `maxTps` from string to number (contract returns numeric strings)
   - [ ] Calculate `minIntervalMicros = lastMint.count * 1_000_000 / parsedMaxTps`
   - [ ] Calculate elapsed time since `lastMint.time`
   - [ ] Return `{ canMint: true }` if elapsed >= minInterval
   - [ ] Return `{ canMint: false, waitMs: remainingMs }` otherwise

3. [ ] Add exports and integrate with OcpClient - low
   - [ ] Export from `src/functions/index.ts`
   - [ ] Optionally add to OcpClient under a new `CouponMinter` namespace

4. [ ] Add unit tests - low
   - [ ] Test case: no maxTps configured → always can mint
   - [ ] Test case: no lastMint → always can mint
   - [ ] Test case: enough time elapsed → can mint
   - [ ] Test case: not enough time elapsed → returns waitMs
   - [ ] Test case: edge cases (zero count, very high TPS, etc.)

## Backend API Changes

None - this is a client-side utility function that performs local calculations.

## UI Behavior

N/A - SDK utility function

## DB Changes

None

## Feature Flag

No

## Mockup

N/A

## Tests

- ✅ `canMintCouponsNow` returns `{ canMint: true }` when maxTps is null (unit)
- ✅ `canMintCouponsNow` returns `{ canMint: true }` when lastMint is null (unit)
- ✅ `canMintCouponsNow` returns `{ canMint: true }` when sufficient time has elapsed (unit)
- ✅ `canMintCouponsNow` returns `{ canMint: false, waitMs }` when rate limited (unit)
- ✅ `canMintCouponsNow` correctly calculates wait time based on lastMint.count (unit)

## Related Issues / Threads

- DAML Contract: `open-captable-protocol-daml/CouponMinter/daml/Fairmint/CouponMinter.daml`
- ADR: `open-captable-protocol-daml/docs/adr/004-couponminter-contract.md`

## Background

The CouponMinter contract is used for minting Featured App Activity Markers (Splice rewards) with
optional on-chain TPS enforcement. When TPS limiting is enabled, the contract tracks the last mint
time and count, then enforces that enough time has passed before allowing another mint operation.

The formula is: `requiredWaitMicros = lastMint.count * 1_000_000 / maxTps`

For example:

- If `maxTps = 5` and `lastMint.count = 10`, you must wait
  `(10 * 1_000_000) / 5 = 2_000_000 microseconds = 2 seconds`
- If `maxTps = 5` and `lastMint.count = 1`, you must wait
  `(1 * 1_000_000) / 5 = 200_000 microseconds = 0.2 seconds`

## Potential Issues and Solutions

1. **Time synchronization**: The client's clock may differ from the ledger's clock. Consider adding
   a small buffer (e.g., 100ms) to the wait time to account for clock drift.

2. **Contract state staleness**: By the time the client submits a transaction, another process may
   have minted, changing the `lastMint` values. Clients should handle transaction failures
   gracefully and retry after re-querying the contract.

## Example Usage

```typescript
import { canMintCouponsNow } from '@open-captable-protocol/canton';

// Query the CouponMinter contract from the ledger
const couponMinter = await ledgerClient.getContractById(couponMinterCid);

// Check if we can mint now
const result = canMintCouponsNow(couponMinter.payload);

if (result.canMint) {
  // Proceed with minting
  await mintCoupons(...);
} else {
  // Wait and retry
  console.log(`Rate limited. Waiting ${result.waitMs}ms...`);
  await sleep(result.waitMs);
  // Retry...
}
```
