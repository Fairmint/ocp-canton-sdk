# Task: Complete OCF SDK Support + Testing Strategy

## Summary

Add SDK support for all remaining OCF object types and establish a robust testing strategy using a
hybrid of unit tests (mocks) and integration tests (LocalNet).

## References

- [DAML Implementation Task](https://github.com/fairmint/open-captable-protocol-daml/blob/main/tasks/2025/12/2025.12.22-complete-ocf-implementation.md)
- [OCF Implementation Status](https://github.com/fairmint/open-captable-protocol-daml/blob/main/docs/OCF_IMPLEMENTATION_STATUS.md)
- [canton-node-sdk LocalNet Guide](https://github.com/fairmint/canton-node-sdk/blob/main/docs/LOCALNET_TESTING.md)

---

## Part 1: Testing Strategy

### Current State

The SDK currently uses:

- **Mock-based unit tests** (`test/mocks/`) - Fast, isolated, deterministic
- **JSON fixtures** (`test/fixtures/createOcf/`) - 30+ OCF object samples
- **OCF schema validation** (`test/utils/ocfSchemaValidator.ts`) - Validates against official
  schemas
- **Basic quickstart smoke test** (`test/integration/`) - Just checks connectivity

### Recommendation: Hybrid Approach

**Keep unit tests with mocks for:**

- Type conversion logic (DAML ↔ OCF)
- Command building (`buildXCommand`)
- Schema validation
- Fast feedback during development (~5s test runs)

**Add integration tests with LocalNet for:**

- Full round-trip: create → read → verify → archive
- Multi-step workflows exercising real DAML contracts
- Discovering bugs in DAML implementation
- Pre-deployment confidence

### Testing Matrix

| Test Type         | Mocks | LocalNet | Purpose                      |
| ----------------- | ----- | -------- | ---------------------------- |
| Type conversions  | ✅    | -        | Validate OCF ↔ DAML mappings |
| Command building  | ✅    | -        | Verify command structure     |
| Schema validation | ✅    | -        | OCF compliance               |
| Round-trip CRUD   | -     | ✅       | Full lifecycle               |
| Workflows         | -     | ✅       | Multi-step scenarios         |
| Error handling    | ✅    | ✅       | Both levels                  |

### Implementation Plan

#### Phase A: Integration Test Infrastructure

- [ ] Add LocalNet setup scripts (leverage canton-node-sdk)
- [ ] Create `jest.localnet.config.js` for integration tests
- [ ] Add npm scripts: `test:localnet`, `localnet:start`, `localnet:stop`
- [ ] Create test utilities for LocalNet (party setup, cleanup)
- [ ] Document setup in `test/integration/README.md`

#### Phase B: Core Integration Tests

- [ ] **Issuer lifecycle**: create → read → verify OCF
- [ ] **Stakeholder lifecycle**: create → read → archive → recreate
- [ ] **Stock class lifecycle**: create → read → archive
- [ ] **Full cap table workflow**:
  1. Create issuer
  2. Create stakeholders (founder, investor)
  3. Create stock class
  4. Issue stock to stakeholders
  5. Read back and verify OCF data

#### Phase C: CI Integration

- [ ] Add LocalNet tests to CI (similar to canton-node-sdk)
- [ ] Run unit tests on every commit
- [ ] Run integration tests on PRs and nightly

---

## Part 2: New OCF Object Types

For each new DAML type, add SDK support following the existing pattern.

### Pattern per Object Type

```
src/functions/OpenCapTable/{entity}/
├── create{Entity}.ts           # Create function + buildCreateCommand
├── get{Entity}AsOcf.ts         # Read function (DAML → OCF)
├── archive{Entity}ByIssuer.ts  # Archive function
└── index.ts                    # Barrel export
```

### High Priority (Core Operations)

- [ ] **TX_STOCK_TRANSFER**
  - `createStockTransfer.ts`
  - `getStockTransferAsOcf.ts`
  - Add test fixtures + integration test

- [ ] **TX_CONVERTIBLE_CONVERSION**
  - `createConvertibleConversion.ts`
  - `getConvertibleConversionAsOcf.ts`
  - Add test fixtures + integration test

- [ ] **TX_WARRANT_EXERCISE**
  - `createWarrantExercise.ts`
  - `getWarrantExerciseAsOcf.ts`
  - Add test fixtures + integration test

- [ ] **TX_STOCK_REPURCHASE**
  - `createStockRepurchase.ts`
  - `getStockRepurchaseAsOcf.ts`
  - Add test fixtures + integration test

- [ ] **Financing** (Object)
  - `createFinancing.ts`
  - `getFinancingAsOcf.ts`
  - Add test fixtures + integration test

### Medium Priority

#### Cancellations

- [ ] TX_CONVERTIBLE_CANCELLATION
- [ ] TX_WARRANT_CANCELLATION
- [ ] TX_EQUITY_COMPENSATION_CANCELLATION

#### Transfers

- [ ] TX_CONVERTIBLE_TRANSFER
- [ ] TX_WARRANT_TRANSFER
- [ ] TX_EQUITY_COMPENSATION_TRANSFER

#### Adjustments

- [ ] TX_STOCK_CLASS_SPLIT
- [ ] TX_STOCK_CLASS_CONVERSION_RATIO_ADJUSTMENT
- [ ] TX_STOCK_PLAN_RETURN_TO_POOL

#### Other

- [ ] TX_EQUITY_COMPENSATION_RELEASE
- [ ] TX_STOCK_CONVERSION

### Lower Priority

- [ ] Vesting transactions (TX_VESTING_START, TX_VESTING_EVENT, TX_VESTING_ACCELERATION)
- [ ] Acceptance transactions (4 types)
- [ ] Retraction transactions (4 types)
- [ ] Other transactions (TX_STOCK_REISSUANCE, TX_STOCK_CONSOLIDATION,
      TX_EQUITY_COMPENSATION_REPRICING)
- [ ] Change events (2 types)

---

## Part 3: Integration Test Scenarios

### Scenario 1: Basic Cap Table Setup

```typescript
test('creates complete cap table', async () => {
  // 1. Create issuer
  const issuer = await ocp.createIssuer({ ... });

  // 2. Create stakeholders
  const founder = await ocp.createStakeholder({ type: 'INDIVIDUAL', ... });
  const investor = await ocp.createStakeholder({ type: 'INSTITUTION', ... });

  // 3. Create stock class
  const commonStock = await ocp.createStockClass({ ... });

  // 4. Issue stock
  const founderShares = await ocp.createStockIssuance({
    stakeholder_id: founder.id,
    stock_class_id: commonStock.id,
    quantity: '1000000',
    ...
  });

  // 5. Verify via getAsOcf
  const ocfIssuer = await ocp.getIssuerAsOcf({ contractId: issuer.contractId });
  await validateOcfObject(ocfIssuer.issuer);
});
```

### Scenario 2: Stock Transfer

```typescript
test('transfers stock between stakeholders', async () => {
  // Setup: issuer, 2 stakeholders, stock class, initial issuance
  // ...

  // Transfer
  const transfer = await ocp.createStockTransfer({
    security_id: originalIssuance.id,
    transferor_stakeholder_id: seller.id,
    transferee_stakeholder_id: buyer.id,
    quantity: '500000',
  });

  // Verify: new issuance for buyer, cancellation for seller
});
```

### Scenario 3: SAFE Conversion

```typescript
test('converts SAFE to stock', async () => {
  // Setup: issuer, stakeholder, SAFE issuance
  // ...

  // Convert
  const conversion = await ocp.createConvertibleConversion({
    security_id: safe.id,
    resulting_security_ids: [stockIssuance.id],
  });

  // Verify: SAFE archived, stock issued
});
```

---

## Files to Create/Modify

### New Files

```
test/integration/
├── README.md                    # LocalNet setup guide
├── scenarios/
│   ├── capTableSetup.test.ts   # Basic cap table workflow
│   ├── stockTransfer.test.ts   # Transfer scenario
│   └── safeConversion.test.ts  # Conversion scenario
└── utils/
    ├── localnetSetup.ts        # Party/issuer setup helpers
    └── cleanup.ts              # Post-test cleanup

src/functions/OpenCapTable/
├── stockTransfer/              # New module
├── convertibleConversion/      # New module
├── warrantExercise/            # New module
├── stockRepurchase/            # New module
└── financing/                  # New module
```

### Modified Files

- `package.json` - Add localnet scripts
- `jest.config.js` - Exclude integration tests from unit run
- `src/OcpClient.ts` - Wire new functions
- `src/functions/OpenCapTable/index.ts` - Export new modules

---

## Validation Commands

```bash
# Unit tests (mocks)
npm test

# Integration tests (requires LocalNet running)
npm run localnet:start
npm run test:localnet
npm run localnet:stop

# Full validation
npm run lint && npx tsc --noEmit && npm test
```

---

## Success Criteria

1. **Testing**
   - [ ] LocalNet integration tests run in CI
   - [ ] Full cap table workflow passes end-to-end
   - [ ] All existing unit tests continue to pass

2. **SDK Coverage**
   - [ ] All high-priority OCF types have SDK support
   - [ ] Each new type has unit test + integration test
   - [ ] OCF schema validation passes for all round-trips

3. **Quality**
   - [ ] No regression in existing functionality
   - [ ] Bugs found in DAML are reported/fixed
   - [ ] Documentation updated

---

## Notes / Decisions Made

- **Hybrid testing**: Mocks for speed, LocalNet for confidence
- **Dependency**: New SDK functions depend on DAML implementation being complete first
- **Coordination**: Run integration tests as DAML types are implemented to catch issues early
- **CI**: Integration tests should run on PR and nightly, not on every commit (too slow)

---

_Last updated: 2025-12-22_
