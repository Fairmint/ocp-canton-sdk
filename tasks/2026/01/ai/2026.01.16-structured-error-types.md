# Structured Error Types

**Date**: 2026-01-16 **Status**: Complete **Priority**: Medium **Parent**:
[Library Refactoring and Testing](./2026.01.02-library-refactoring-and-testing.md)

## Overview

Implement structured error types to provide better error handling, debugging, and developer
experience when working with the OCP SDK.

## Current State

The SDK currently uses generic `Error` objects with string messages:

```typescript
// Current error patterns
throw new Error('stakeholder.id is required');
throw new Error('UpdateCapTable result not found in transaction tree');
throw new Error('Cannot build empty batch - add at least one create, edit, or delete operation');
```

### Issues

1. **No error categorization** - All errors are generic `Error` instances
2. **No structured metadata** - Contract IDs, field paths, values not included
3. **Difficult to handle programmatically** - Cannot catch specific error types
4. **Limited debugging context** - Errors don't include original cause or stack traces

## Goals

### 1. Error Type Hierarchy

Create a hierarchy of error types for different failure modes:

```typescript
// src/errors/index.ts

/** Base error class for all OCP SDK errors */
export class OcpError extends Error {
  readonly code: string;
  readonly cause?: Error;

  constructor(message: string, code: string, cause?: Error) {
    super(message);
    this.name = 'OcpError';
    this.code = code;
    this.cause = cause;
  }
}

/** Validation errors for invalid input data */
export class OcpValidationError extends OcpError {
  readonly fieldPath: string;
  readonly expectedType?: string;
  readonly receivedValue?: unknown;

  constructor(
    fieldPath: string,
    message: string,
    options?: {
      expectedType?: string;
      receivedValue?: unknown;
    }
  ) {
    super(`Validation error at '${fieldPath}': ${message}`, 'VALIDATION_ERROR');
    this.name = 'OcpValidationError';
    this.fieldPath = fieldPath;
    this.expectedType = options?.expectedType;
    this.receivedValue = options?.receivedValue;
  }
}

/** Errors from Canton/DAML contract interactions */
export class OcpContractError extends OcpError {
  readonly contractId?: string;
  readonly templateId?: string;
  readonly choice?: string;

  constructor(
    message: string,
    options?: {
      contractId?: string;
      templateId?: string;
      choice?: string;
      cause?: Error;
    }
  ) {
    super(message, 'CONTRACT_ERROR', options?.cause);
    this.name = 'OcpContractError';
    this.contractId = options?.contractId;
    this.templateId = options?.templateId;
    this.choice = options?.choice;
  }
}

/** Network or connectivity errors */
export class OcpNetworkError extends OcpError {
  readonly endpoint?: string;
  readonly statusCode?: number;

  constructor(
    message: string,
    options?: {
      endpoint?: string;
      statusCode?: number;
      cause?: Error;
    }
  ) {
    super(message, 'NETWORK_ERROR', options?.cause);
    this.name = 'OcpNetworkError';
    this.endpoint = options?.endpoint;
    this.statusCode = options?.statusCode;
  }
}

/** Errors from parsing or transforming data */
export class OcpParseError extends OcpError {
  readonly source?: string;

  constructor(
    message: string,
    options?: {
      source?: string;
      cause?: Error;
    }
  ) {
    super(message, 'PARSE_ERROR', options?.cause);
    this.name = 'OcpParseError';
    this.source = options?.source;
  }
}
```

### 2. Improved Validation Messages

Update validation to use structured errors:

```typescript
// Before
if (!d.id) throw new Error('stakeholder.id is required');

// After
if (!d.id) {
  throw new OcpValidationError('stakeholder.id', 'Required field is missing or empty', {
    expectedType: 'string',
    receivedValue: d.id,
  });
}
```

### 3. Error Codes for Programmatic Handling

Define error codes for common error conditions:

```typescript
export const OcpErrorCodes = {
  // Validation errors
  REQUIRED_FIELD_MISSING: 'REQUIRED_FIELD_MISSING',
  INVALID_TYPE: 'INVALID_TYPE',
  INVALID_FORMAT: 'INVALID_FORMAT',
  OUT_OF_RANGE: 'OUT_OF_RANGE',

  // Contract errors
  CONTRACT_NOT_FOUND: 'CONTRACT_NOT_FOUND',
  CHOICE_FAILED: 'CHOICE_FAILED',
  AUTHORIZATION_FAILED: 'AUTHORIZATION_FAILED',

  // Network errors
  CONNECTION_FAILED: 'CONNECTION_FAILED',
  TIMEOUT: 'TIMEOUT',
  RATE_LIMITED: 'RATE_LIMITED',

  // Parse errors
  INVALID_RESPONSE: 'INVALID_RESPONSE',
  SCHEMA_MISMATCH: 'SCHEMA_MISMATCH',
} as const;
```

### 4. Error Handling Examples

```typescript
try {
  await ocp.OpenCapTable.capTable
    .update({ capTableContractId, featuredAppRightContractDetails, actAs })
    .create('stakeholder', invalidData)
    .execute();
} catch (error) {
  if (error instanceof OcpValidationError) {
    console.error(`Invalid input at ${error.fieldPath}: ${error.message}`);
    console.error(`Expected: ${error.expectedType}, Got: ${error.receivedValue}`);
  } else if (error instanceof OcpContractError) {
    console.error(`Contract error on ${error.choice}: ${error.message}`);
    console.error(`Contract ID: ${error.contractId}`);
  } else if (error instanceof OcpError) {
    console.error(`OCP Error [${error.code}]: ${error.message}`);
  } else {
    throw error; // Re-throw unknown errors
  }
}
```

## Implementation Plan

### Phase 1: Create Error Classes

- [x] Create `src/errors/OcpError.ts` base class
- [x] Create `src/errors/OcpValidationError.ts`
- [x] Create `src/errors/OcpContractError.ts`
- [x] Create `src/errors/OcpNetworkError.ts`
- [x] Create `src/errors/OcpParseError.ts`
- [x] Create `src/errors/index.ts` barrel export
- [x] Define error codes in `src/errors/codes.ts`

### Phase 2: Update Validation Code

- [x] Update `stakeholderDataToDaml.ts` to use `OcpValidationError`
- [x] Update `stockIssuanceDataToDaml.ts` to use `OcpValidationError`
- [x] Update other entity converters (ocfToDaml.ts, stockClassDataToDaml.ts,
      stockRepurchaseDataToDaml.ts, createIssuer.ts)
- [x] Update `normalizeNumericString()` to use structured errors

### Phase 3: Update SDK Methods

- [x] Update `CapTableBatch.execute()` to wrap errors
- [x] Update `get*AsOcf()` methods to wrap parse errors (getStakeholderAsOcf.ts)
- [x] Update typeConversions to wrap errors (extractUpdateId, address type conversions)

### Phase 4: Documentation

- [x] Add JSDoc documentation with examples to error classes
- [x] Add examples for catching specific error types in index.ts
- [x] Document error codes and their meanings in codes.ts

## Files to Create

- `src/errors/OcpError.ts`
- `src/errors/OcpValidationError.ts`
- `src/errors/OcpContractError.ts`
- `src/errors/OcpNetworkError.ts`
- `src/errors/OcpParseError.ts`
- `src/errors/codes.ts`
- `src/errors/index.ts`
- `test/errors/errors.test.ts`

## Files to Modify

- `src/index.ts` - Export error classes
- All `*DataToDaml.ts` files
- `src/functions/OpenCapTable/capTable/CapTableBatch.ts`
- `src/utils/typeConversions.ts`

## Validation

```bash
npm run fix                    # Lint/format
npm run typecheck              # Type check
npm test                       # Unit tests
npm run test:integration       # Integration tests
```

## Related

- [Library Refactoring and Testing](./2026.01.02-library-refactoring-and-testing.md)
- [Consolidate Entity Converters](./2026.01.16-consolidate-entity-converters.md)

## Changelog

| Date       | Change                             | PRs                                |
| ---------- | ---------------------------------- | ---------------------------------- |
| 2026-01-16 | Created task                       | --                                 |
| 2026-01-20 | Implemented structured error types | cursor/structured-error-types-b5be |

---

_Last updated: 2026-01-20_
