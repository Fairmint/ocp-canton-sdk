# Task: PQS (Participant Query Store) Support

## Status: Open

**Created**: 2026-01-16  
**Priority**: Low  
**Source**: [Canton Network TL;DR Documentation](https://docs.digitalasset.com/build/3.4/overview/tldr.html)

## Summary

Evaluate and potentially add support for the Participant Query Store (PQS) as an alternative to
direct Ledger API queries for improved read performance.

## Background

The Canton Network documentation recommends a two-path architecture for ledger interactions:

| Operation Type | Recommended Path              | Purpose                                |
| -------------- | ----------------------------- | -------------------------------------- |
| **Queries**    | PQS (Participant Query Store) | Fast read access to ledger state       |
| **Commands**   | Ledger API (GRPC/HTTP)        | Exercising choices, creating contracts |

From the CN Quickstart Project Structure documentation:

> The backend is a Spring Boot application that mediates ALL ledger interactions using two distinct
> paths:
>
> 1. **Queries** → PQS (Participant Query Store) for fast read access to ledger state
> 2. **Commands** → Ledger API GRPC for exercising choices and creating contracts

Benefits of PQS:

- **Performance**: Optimized for read queries, can handle higher query volumes
- **Flexibility**: SQL-like query capabilities
- **Scalability**: Offloads read traffic from the participant node
- **Historical data**: Can query historical contract states

Currently, the SDK:

- Uses direct Ledger API for all operations (both reads and writes)
- Does not have PQS integration
- All `getXAsOcf` functions use Ledger API queries

## Analysis Required

Before implementation, we should analyze:

1. **Is PQS available?**
   - PQS requires additional infrastructure (PostgreSQL, sync process)
   - May not be available in all deployments

2. **Performance comparison**:
   - Benchmark current Ledger API query performance
   - Determine if PQS would provide meaningful improvement

3. **Complexity vs benefit**:
   - PQS adds operational complexity
   - SDK consumers may not have PQS deployed

## Potential Implementation

### Option A: Direct PQS Client

Add PQS client for optimized queries:

```typescript
export interface PqsClientOptions {
  connectionString: string;
  schema?: string;
}

export class PqsClient {
  async queryContracts<T>(templateId: string, filters?: Record<string, unknown>): Promise<T[]>;

  async getContract<T>(contractId: string): Promise<T | null>;
}
```

### Option B: Abstracted Query Layer

Create abstraction that can use either Ledger API or PQS:

```typescript
export interface QueryProvider {
  queryActiveContracts<T>(templateId: string): Promise<T[]>;
  getContractById<T>(contractId: string): Promise<T | null>;
}

// Implementations
export class LedgerApiQueryProvider implements QueryProvider { ... }
export class PqsQueryProvider implements QueryProvider { ... }

// OcpClient accepts either
const client = new OcpClient({
  queryProvider: new PqsQueryProvider(connectionString),
});
```

### Option C: Documentation Only

Document PQS patterns without SDK integration:

- Explain when to use PQS vs Ledger API
- Provide example PQS queries for common OCF operations
- Let SDK consumers integrate PQS in their application layer

## Recommended Approach

**Start with Option C (Documentation Only)**:

1. Document the PQS architecture pattern
2. Explain the trade-offs
3. Provide SQL query examples for common operations
4. Consider full integration in future versions if demand exists

This approach:

- Doesn't add SDK complexity
- Respects that not all deployments have PQS
- Gives consumers flexibility
- Can be expanded based on feedback

## Testing Requirements

If implementing PQS support:

- [ ] Unit tests for PQS query parsing
- [ ] Integration tests with LocalNet PQS
- [ ] Performance benchmarks comparing Ledger API vs PQS
- [ ] Fallback behavior when PQS unavailable

## Acceptance Criteria

### Option C (Documentation):

- [ ] Document PQS architecture pattern
- [ ] Explain when to use PQS vs Ledger API
- [ ] Provide example SQL queries for OCF contracts
- [ ] Update llms.txt with PQS considerations

### Full Implementation (Future):

- [ ] PQS client integration
- [ ] Query abstraction layer
- [ ] Automatic fallback to Ledger API
- [ ] Performance documentation

## Related Documentation

- [CN Quickstart Project Structure - Backend Architecture](https://docs.digitalasset.com/build/3.4/quickstart/configure/project-structure-overview.html#backend-architecture-pattern)
- [CN Quickstart FAQ - Database Access](https://docs.digitalasset.com/build/3.4/quickstart/troubleshoot/cnqs-faq.html#database-query-access)

## Notes

- PQS is not a requirement for the SDK to function
- Consider this a "nice to have" optimization
- Priority should be given to core functionality first
- SDK consumers using the CN Quickstart template already have PQS patterns
