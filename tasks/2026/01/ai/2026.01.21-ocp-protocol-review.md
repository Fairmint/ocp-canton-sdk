# OCP Protocol Implementation Review

**Date**: 2026-01-21  
**Status**: Review Complete  
**Author**: Cursor Agent

## Executive Summary

This document provides an honest assessment of the OCP Canton SDK implementation and proposes
improvement tasks prioritized for a pre-user-adoption timeframe. The SDK has solid foundations—good
error handling, a batch API via ADR-001, and comprehensive type definitions—but several
architectural issues and DX problems should be addressed before users adopt it.

**Key Findings:**

- API surface is inconsistent—some operations use batch API, some use direct methods
- DAML↔OCF conversion code is duplicated and scattered across files
- `OcpClient` is bloated (650+ lines) and hard to navigate
- Many `get*AsOcf` functions have duplicated patterns
- No clear path for discovering available operations
- Missing inverse operations (`damlToOcf` converters for batch entities)

---

## Issue Categories

### 1. API Design & Developer Experience (HIGH PRIORITY)

#### Issue 1.1: Inconsistent API Patterns

**Problem:** The `OcpClient` exposes operations in three different patterns:

1. **Batch API** via `capTable.update()` — modern, fluent builder
2. **Direct methods** like `getIssuerAsOcf()` — async functions on entity namespaces
3. **Build commands** like `buildCreateIssuerCommand()` — for manual submission

This creates confusion about which pattern to use when.

**Evidence:**

```typescript
// Pattern 1: Batch API (only for writes)
ocp.OpenCapTable.capTable.update(...).create('stakeholder', data).execute();

// Pattern 2: Direct read method
await ocp.OpenCapTable.issuer.getIssuerAsOcf({ contractId });

// Pattern 3: Build command (for issuer creation specifically)
ocp.OpenCapTable.issuer.buildCreateIssuerCommand(params);
```

**Recommendation:** Unify the API into a consistent pattern. Either:

- **Option A:** Batch API for all writes, direct methods for reads
- **Option B:** Resource-oriented API like `ocp.stakeholder.create()`, `ocp.stakeholder.get()`

---

#### Issue 1.2: Missing Write Operations in Batch API

**Problem:** The batch API supports `create`, `edit`, `delete` for most entities, but the issuer
itself cannot be created via batch—it requires `buildCreateIssuerCommand()`.

**Evidence:** The issuer is created via `CreateCapTable` choice on `IssuerAuthorization`, not
`UpdateCapTable`.

**Recommendation:** Document this clearly or provide a unified `ocp.issuer.create()` method that
abstracts the difference.

---

#### Issue 1.3: OcpClient is Bloated

**Problem:** `OcpClient.ts` is 650+ lines with:

- Interface definitions inline
- Method wiring for all entity types
- Context manager class
- Three namespace hierarchies

**Recommendation:** Split into:

- `OcpClient.ts` — Core class only (~100 lines)
- `OcpClientTypes.ts` — Interface definitions
- `OcpContextManager.ts` — Context caching (already a separate class)
- `methods/` — Auto-generated method bindings

---

### 2. Architecture & Code Organization (HIGH PRIORITY)

#### Issue 2.1: Scattered Conversion Logic

**Problem:** DAML↔OCF conversion functions are scattered:

- `src/functions/OpenCapTable/*/create*.ts` — `*DataToDaml` functions
- `src/functions/OpenCapTable/*/get*AsOcf.ts` — `daml*ToNative` functions
- `src/functions/OpenCapTable/capTable/ocfToDaml.ts` — dispatcher
- `src/utils/typeConversions.ts` — shared helpers

**Evidence:** The same enum conversion logic appears in multiple files:

```typescript
// In createIssuer.ts
function emailTypeToDaml(emailType: EmailType): Fairmint.OpenCapTable.Types.OcfEmailType {
  switch (emailType) { ... }
}

// In getIssuerAsOcf.ts
function damlEmailTypeToNative(damlType: Fairmint.OpenCapTable.Types.OcfEmailType): EmailType {
  switch (damlType) { ... }
}
```

**Recommendation:** Create a `src/converters/` directory with:

- `src/converters/enums.ts` — all enum conversions (bidirectional)
- `src/converters/types.ts` — shared type conversions
- `src/converters/entities/<entity>.ts` — entity-specific conversions
- `src/converters/index.ts` — unified `toDaml()` and `toOcf()` dispatchers

---

#### Issue 2.2: Missing `damlToOcf` Dispatcher

**Problem:** There's a centralized `convertToDaml()` dispatcher for batch writes, but no equivalent
for reads. Each `get*AsOcf` function duplicates the contract fetch + transform pattern.

**Evidence:**

```typescript
// Repeated in every get*AsOcf.ts
const eventsResponse = await client.getEventsByContractId({ contractId });
if (!eventsResponse.created?.createdEvent.createArgument) {
  throw new Error('Invalid contract events response');
}
// ... entity-specific transform
```

**Recommendation:** Create a generic `getEntityAsOcf<T>()` helper:

```typescript
async function getEntityAsOcf<T extends OcfEntityType>(
  client: LedgerJsonApiClient,
  entityType: T,
  contractId: string
): Promise<OcfDataTypeFor<T>> {
  const eventsResponse = await client.getEventsByContractId({ contractId });
  const createArg = extractCreateArgument(eventsResponse);
  return convertToOcf(entityType, createArg);
}
```

---

#### Issue 2.3: Unused Legacy Functions

**Problem:** Some entity folders still contain individual `create*`, `edit*`, `delete*` functions
that were superseded by the batch API but weren't removed.

**Recommendation:** Remove unused legacy functions or mark them `@deprecated` and document the
migration path.

---

### 3. Type Safety & Validation (MEDIUM PRIORITY)

#### Issue 3.1: Excessive Type Casting in Converters

**Problem:** Many `get*AsOcf` functions use `as unknown as Record<string, unknown>` patterns.

**Evidence:**

```typescript
// From getStockClassAsOcf.ts
const dAny = damlData as unknown as Record<string, unknown>;
// ... later
const isa = dAny.initial_shares_authorized;
if (typeof isa === 'string' || typeof isa === 'number') { ... }
```

**Recommendation:** Define explicit DAML response types or use type guards:

```typescript
function isDamlStockClassData(arg: unknown): arg is DamlStockClassData {
  return typeof arg === 'object' && arg !== null && 'stock_class_data' in arg;
}
```

---

#### Issue 3.2: Optional Field Handling Inconsistency

**Problem:** Some functions use `??`, some use `||`, some use explicit null checks.

**Evidence:**

```typescript
// Mixed patterns
out.dba = damlData.dba; // Direct assignment (may be undefined)
out.id = dataWithId.id ?? ''; // Nullish coalescing
if (damlData.email) out.email = damlEmailToNative(damlData.email); // Explicit check
```

**Recommendation:** Standardize on `??` for nullish coalescing and explicit guards for objects.

---

#### Issue 3.3: Missing Input Validation

**Problem:** The batch API validates `id` field presence but not other required fields. Invalid data
may pass to DAML and fail at contract execution time with cryptic errors.

**Recommendation:** Add comprehensive input validation in `convertToDaml()`:

```typescript
function validateStakeholderInput(data: OcfStakeholder): void {
  if (!data.id) throw new OcpValidationError('stakeholder.id', 'Required');
  if (!data.name?.legal_name)
    throw new OcpValidationError('stakeholder.name.legal_name', 'Required');
  if (!data.stakeholder_type)
    throw new OcpValidationError('stakeholder.stakeholder_type', 'Required');
}
```

---

### 4. Error Handling (MEDIUM PRIORITY)

#### Issue 4.1: Good Error Types, Inconsistent Usage

**Problem:** The SDK has well-defined error types (`OcpValidationError`, `OcpContractError`,
`OcpParseError`, `OcpNetworkError`) but they're not consistently used.

**Evidence:**

```typescript
// Some functions use OcpValidationError
throw new OcpValidationError('issuer.id', 'Required field is missing', { ... });

// Others use plain Error
throw new Error('Invalid contract events response');
```

**Recommendation:** Audit all `throw new Error()` calls and replace with appropriate OCP error
types.

---

#### Issue 4.2: Missing Error Context

**Problem:** When batch operations fail, the error doesn't indicate which entity in the batch caused
the failure.

**Recommendation:** Add batch context to errors:

```typescript
catch (error) {
  throw new OcpContractError('Batch update failed', {
    batchSize: this.size,
    creates: this.creates.length,
    edits: this.edits.length,
    deletes: this.deletes.length,
    cause: error,
  });
}
```

---

### 5. Testing & Quality (LOW-MEDIUM PRIORITY)

#### Issue 5.1: Unit Test Coverage Gaps

**Problem:** The `ocfToDaml.ts` dispatcher has 48 entity cases but limited unit tests.

**Recommendation:** Add property-based tests using a library like `fast-check`:

```typescript
test.prop([fc.record({ id: fc.uuid(), name: fc.object({ legal_name: fc.string() }) })])(
  'stakeholderDataToDaml preserves id',
  (data) => {
    const result = convertToDaml('stakeholder', data as OcfStakeholder);
    expect(result.id).toBe(data.id);
  }
);
```

---

#### Issue 5.2: Missing Round-Trip Tests

**Problem:** No tests verify that `toDaml → toOcf` round-trips produce equivalent data.

**Recommendation:** Add round-trip tests for each entity type:

```typescript
test('stakeholder round-trips correctly', () => {
  const original: OcfStakeholder = { id: 'sh-1', name: { legal_name: 'Test' }, ... };
  const daml = convertToDaml('stakeholder', original);
  const roundTripped = convertToOcf('stakeholder', daml);
  expect(roundTripped).toEqual(original);
});
```

---

### 6. Documentation (LOW PRIORITY)

#### Issue 6.1: Missing JSDoc on Public Methods

**Problem:** Many public methods lack JSDoc documentation.

**Recommendation:** Add JSDoc to all public API methods with:

- Description
- `@param` for each parameter
- `@returns` description
- `@throws` for known error types
- `@example` for common use cases

---

#### Issue 6.2: No Migration Guide from Legacy API

**Problem:** Users who adopted the old individual functions have no migration guide to the batch
API.

**Recommendation:** Create `docs/MIGRATION.md` documenting:

- Old API patterns
- New batch API equivalents
- Breaking changes
- Code transformation examples

---

### 7. Performance & Scalability (LOW PRIORITY)

#### Issue 7.1: No Batch Size Limits

**Problem:** The batch API doesn't enforce or document maximum batch sizes. Large batches may
timeout or fail.

**Recommendation:** Add configurable limits and pagination:

```typescript
const MAX_BATCH_SIZE = 100;

create<T extends OcfEntityType>(type: T, data: OcfDataTypeFor<T>): this {
  if (this.size >= MAX_BATCH_SIZE) {
    throw new OcpValidationError('batch', `Maximum batch size (${MAX_BATCH_SIZE}) exceeded`);
  }
  // ...
}
```

---

## Proposed Task Breakdown

Based on this review, I recommend the following tasks in priority order:

### Immediate (Before User Adoption)

1. **[API Consistency Refactor](./2026.01.21-api-consistency-refactor.md)** — HIGH Unify API
   patterns, document when to use batch vs direct methods

2. **[Centralize Converters](./2026.01.21-centralize-converters.md)** — HIGH Create
   `src/converters/` with bidirectional conversions

3. **[Add damlToOcf Dispatcher](./2026.01.21-daml-to-ocf-dispatcher.md)** — HIGH Generic
   `getEntityAsOcf<T>()` function to DRY up read operations

4. **[Standardize Error Usage](./2026.01.21-standardize-error-usage.md)** — MEDIUM Replace
   `new Error()` with appropriate OCP error types

### Short-term (Within 2-4 weeks)

5. **[Split OcpClient](./2026.01.21-split-ocp-client.md)** — MEDIUM Break `OcpClient.ts` into
   focused modules

6. **[Input Validation Layer](./2026.01.21-input-validation-layer.md)** — MEDIUM Comprehensive
   validation before DAML conversion

7. **[Round-trip Tests](./2026.01.21-round-trip-tests.md)** — MEDIUM Property-based and round-trip
   tests for converters

### Longer-term (When Time Permits)

8. **[JSDoc Coverage](./2026.01.21-jsdoc-coverage.md)** — LOW Add comprehensive documentation to
   public API

9. **[Migration Guide](./2026.01.21-migration-guide.md)** — LOW Document migration from legacy to
   batch API

10. **[Batch Size Limits](./2026.01.21-batch-size-limits.md)** — LOW Add configurable limits and
    pagination support

---

## Summary

The OCP Canton SDK is well-structured for a complex domain with solid foundations in error handling
and type definitions. The batch API (ADR-001) is a good architectural direction. However, the
codebase has accumulated inconsistencies from iterative development that should be addressed before
users adopt it.

**Top 3 Recommendations:**

1. Centralize conversion logic to eliminate duplication
2. Unify API patterns for consistency
3. Add comprehensive input validation to fail fast with clear errors

Since there are no users yet, now is the ideal time to make breaking changes that improve the
long-term maintainability and developer experience.
